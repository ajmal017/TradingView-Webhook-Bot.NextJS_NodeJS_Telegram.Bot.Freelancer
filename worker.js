const puppeteer = require("puppeteer-extra");
const StealthPlugin = require("puppeteer-extra-plugin-stealth");
const Telegram = require("telegraf/telegram");

const { sequelize, defaultRows, Message, Setting } = require("./models");

puppeteer.use(StealthPlugin());

/**
 * A function that update's the worker activity status in Database
 */
async function updateStatus(initial = false) {
  if (initial) {
    return await Setting.findOrCreate({
      where: { type: "worker", data: new Date().toISOString(), enabled: false },
    });
  }

  await Setting.update(
    { data: new Date().toISOString() },
    { where: { type: "worker" } }
  );
}

/**
 * A function that will obtain the URL of a screenshot generated by TradingView.
 *
 * @param {class} page - A puppeteer page instance
 * @param {object} options - Options used while taking a screenshot
 *
 * @returns {string} - The screenshot Image URL
 */
async function screenshot(page, { symbol, timeframe }) {
  // Go to symbol page
  await page.goto(`https://www.tradingview.com/symbols/${symbol}/`);
  await page.waitForSelector('a[href*="/chart/?"]');
  const graph_url = await page.evaluate(
    () => document.querySelector('a[href*="/chart/?"]').href
  );

  // Go to graph page
  await page.goto(graph_url);
  await page.waitForSelector(".item-3cgIlGYO");
  await page.evaluate((timeframe) => {
    document.querySelectorAll(".item-3cgIlGYO").forEach((tag) => {
      if (tag.textContent !== timeframe) return;

      tag.click();
    });
  });

  // Wait for image generation
  await page.waitForSelector("[class='chart-loading-screen']");
  await page.click("#header-toolbar-screenshot");
  await page.waitForSelector('[value*="https://www.tradingview.com/x/"]');

  // Get image URL
  const image_url = await page.evaluate(() => {
    return document.querySelector('[value*="https://www.tradingview.com/x/"]')
      .value;
  });

  return image_url;
}

/**
 * A worker that is called periodically to dispatch messages.
 *
 * @param {class} page - A puppeteer page instance
 */
async function processQueue(page) {
  const bot_settings = await Setting.findOne({ where: { type: "bot" } });
  const screenshot_settings = await Setting.findOne({
    where: { type: "screenshot" },
  });
  const messages = await Message.findAll({ where: { status: "pending" } });

  console.log(new Date(), "Pending messages:", messages.length);

  const bot = new Telegram(bot_settings["data"]);

  // Iterate over all messages
  for (let i = 0; i < messages.length; i++) {
    const message = messages[i];
    const id = message["id"];
    const data = message["data"];
    const channels = message["channels"].split(",");
    const symbol = data.split(" ")[0];

    console.log(new Date(), "Processing Message ID:", id);

    // Iterate over all channels
    for (let j = 0; j < channels.length; j++) {
      const channel = channels[j];
      let image = null;

      if (screenshot_settings["enabled"]) {
        try {
          image = await screenshot(page, {
            symbol,
            timeframe: screenshot_settings["data"],
          });
          console.log(new Date(), "Screenshot SUCCESS:", symbol);
        } catch (err) {
          image =
            "https://miro.medium.com/max/978/1*pUEZd8z__1p-7ICIO1NZFA.png";
          console.log(new Date(), "Screenshot FAILED:", symbol);
        }
      }

      // Dispatch messages
      try {
        if (screenshot_settings["enabled"]) {
          await bot.sendPhoto(channel, image, { caption: data });
        } else {
          await bot.sendMessage(channel, data);
        }

        await Message.update({ status: "done" }, { where: { id } });

        console.log(new Date(), "Dispatch SUCCESS:", channel);
      } catch (err) {
        console.log(err);
        console.log(new Date(), "Dispatch FAILED:", channel);
      }

      // Update worker status
      await updateStatus();
    }
  }
}

/**
 * Init worker function
 */
async function init() {
  console.log(new Date(), "Worker started");

  // Update status
  await updateStatus(true);

  /**********************
   * INITILIZE DATABASE *
   **********************/

  await sequelize.sync();
  await defaultRows();

  /**********************
   * INITIALIZE BROWSER *
   **********************/
  const browser = await puppeteer.launch({
    headless: true,
    args: ["--start-fullscreen", "--no-sandbox", "--window-size=1366,768"],
  });
  const page = (await browser.pages())[0];

  // Confirm leaving page without saving
  page.on("dialog", async (dialog) => {
    await dialog.accept();
  });

  console.log(new Date(), "Browser session opened");

  /********************
   * PROCESS MESSAGES *
   ********************/
  while (true) {
    // Update worker stats
    console.log(new Date(), "Checking Queue");

    await updateStatus();

    try {
      // Process Queue
      await processQueue(page);
    } catch (err) {
      console.log(err);
    }

    const wait = 10; // seconds
    console.log(new Date(), `Recheck Queue in: ${wait} seconds`);

    // Sleep
    await new Promise((resolve) => setTimeout(resolve, wait * 1000));
  }

  /*****************
   * CLOSE BROWSER *
   *****************/
  await browser.close();
}

init();
